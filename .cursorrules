# AI Coding Assistant Rules for Next.js + shadcn/ui + TypeScript

You are an expert in Solidity, TypeScript, Node.js, Next.js 14 App Router, React, Vite, Viem v2, Wagmi v2, Shadcn UI, Radix UI, Tailwind CSS, Web3.js, and Solana development.

## Core Principles

- Write concise, technical responses with accurate TypeScript examples
- Use functional, declarative programming; avoid classes
- Prefer iteration and modularization over duplication
- Use descriptive variable names with auxiliary verbs (e.g., `isLoading`, `hasError`)
- Use lowercase with dashes for directories (e.g., `components/auth-wizard`)
- Favor named exports for components
- Follow the Receive an Object, Return an Object (RORO) pattern

## TypeScript & JavaScript

- Use TypeScript for all code; prefer interfaces over types
- Avoid enums; use maps or const objects instead
- Use the `function` keyword for pure functions; omit semicolons
- Use concise, one-line syntax for simple conditionals
- Prioritize type safety and modularization

### File Structure

- Include exported component, subcomponents, helpers, static content, and types in the same file or logical group
- Avoid unnecessary curly braces in conditionals

## React & Next.js

### Component Guidelines

- Use functional components with TypeScript interfaces
- Write declarative JSX
- Use the `function` keyword for components instead of `const`
- Follow mobile-first approach with Tailwind CSS

### Performance Optimization

- Minimize `use client`, `useEffect`, and `setState`
- Prefer React Server Components (RSC) for rendering and state management
- Wrap client components in `Suspense` with appropriate fallbacks
- Optimize images: use WebP format, proper size data, lazy loading

### State Management

- Leverage `useActionState` with `next-safe-action` for type-safe server actions
- Use Zod for validation and input handling
- Implement consistent error handling and success responses

### Forms

- Use `react-hook-form` with Zod validation
- All server actions must:
  - Use Zod schemas for input validation
  - Return consistent `ActionResponse` type
  - Handle errors gracefully

## shadcn/ui Guidelines

### Component Usage

- Always use shadcn/ui components from `@/components/ui`
- Import components: `import { Button } from "@/components/ui/button"`
- Use the `cn()` utility for className management: `import { cn } from "@/lib/utils"`

### Styling with Tailwind

- Use Tailwind utility classes for styling
- Leverage CSS variables for theming (defined in `globals.css`)
- Follow the shadcn/ui design system:
  - Colors: `bg-background`, `text-foreground`, `border`, etc.
  - Spacing: Use consistent spacing scale
  - Typography: Use defined text styles

### Component Patterns

```typescript
// ✅ Good - Using shadcn/ui Button with variants
import { Button } from "@/components/ui/button";

function MyComponent() {
  return (
    <Button variant="default" size="lg">
      Click me
    </Button>
  );
}

// ✅ Good - Composing with cn utility
import { cn } from "@/lib/utils";

function Card({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("rounded-lg border bg-card p-6", className)}
      {...props}
    />
  );
}
```

### Common Components

- **Buttons**: Use `<Button>` with variants (default, destructive, outline, secondary, ghost, link)
- **Cards**: Use `<Card>`, `<CardHeader>`, `<CardTitle>`, `<CardContent>`
- **Forms**: Use `<Form>`, `<FormField>`, `<FormItem>`, `<FormLabel>`, `<FormControl>`, `<FormMessage>`
- **Dialogs**: Use `<Dialog>`, `<DialogTrigger>`, `<DialogContent>`, `<DialogHeader>`
- **Tables**: Use `<Table>`, `<TableHeader>`, `<TableBody>`, `<TableRow>`, `<TableCell>`

### Adding New Components

When installing new shadcn/ui components:

```bash
npx shadcn add button
npx shadcn add card
npx shadcn add dialog
```

## Error Handling

- Handle errors and edge cases at the start of functions
- Use early returns for invalid states
- Avoid unnecessary `else` statements; use `if-return` pattern
- Use guard clauses for preconditions
- Implement proper error logging and user-friendly messages
- Use custom error types for consistent handling

## Accessibility (a11y)

- Use semantic HTML elements
- Include proper ARIA labels and roles
- Ensure keyboard navigation works
- Test with screen readers
- Maintain sufficient color contrast
- Use focus indicators

## Performance Best Practices

- Prioritize Core Web Vitals (LCP, CLS, FID)
- Use Next.js App Router for routing and state changes
- Implement code splitting and lazy loading
- Optimize asset loading (images, fonts, scripts)
- Minimize JavaScript bundle size

## Blockchain Development

### Web3.js & Ethereum

- Use `web3.js` for Ethereum interactions
- Secure private key handling via environment variables
- Optimize gas usage in smart contract calls
- Validate and sanitize user input before blockchain interactions

### Viem v2 & Wagmi v2

- Use Wagmi hooks for wallet connections
- Use Viem for type-safe blockchain queries
- Handle wallet connection states properly

### Solana Development

- Use `@solana/web3.js` for Solana operations
- Follow transaction signing best practices
- Use `TransactionInstruction` for composing transactions
- Implement efficient error handling for blockchain queries

## File Organization Rules

### Critical Rules

- **NEVER create new files or folders unless explicitly instructed**
- Work strictly within existing `src` or `app` folder structure
- Always analyze existing file structure before suggesting changes
- Reference exact files with paths relative to project root
- Maintain clear memory of all files, structures, and changes
- Never delete working code

### When Suggesting Changes

- Provide exact file paths (e.g., `app/components/ui/Button.tsx`)
- Explain reasoning for architectural decisions
- Ensure compatibility across the codebase
- Document changes and justify them

## Code Style

### Naming Conventions

- Components: PascalCase (e.g., `UserProfile`)
- Functions: camelCase (e.g., `getUserData`)
- Files: kebab-case for directories, PascalCase for components
- Constants: UPPER_SNAKE_CASE (e.g., `API_KEY`)

### Import Order

```typescript
// 1. External imports
import React from "react";
import { useRouter } from "next/navigation";

// 2. Internal imports - components
import { Button } from "@/components/ui/button";
import { Header } from "@/components/Header";

// 3. Internal imports - utilities
import { cn } from "@/lib/utils";
import { formatDate } from "@/lib/format";

// 4. Types
import type { User } from "@/types";
```

## shadcn/ui Component Examples

### Button Patterns

```typescript
import { Button } from "@/components/ui/button";
import { ArrowRight, Loader2 } from "lucide-react";

function ButtonExamples() {
  return (
    <>
      <Button>Default</Button>
      <Button variant="destructive">Delete</Button>
      <Button variant="outline">Outline</Button>
      <Button variant="ghost">Ghost</Button>
      <Button size="sm">Small</Button>
      <Button size="lg">Large</Button>
      <Button disabled>
        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
        Loading
      </Button>
      <Button>
        Next
        <ArrowRight className="ml-2 h-4 w-4" />
      </Button>
    </>
  );
}
```

### Form Pattern

```typescript
"use client";

import { zodResolver } from "@hookform/resolvers/zod";
import { useForm } from "react-hook-form";
import * as z from "zod";
import { Button } from "@/components/ui/button";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";

const formSchema = z.object({
  username: z.string().min(2).max(50),
  email: z.string().email(),
});

export function ProfileForm() {
  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      username: "",
      email: "",
    },
  });

  function onSubmit(values: z.infer<typeof formSchema>) {
    console.log(values);
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-8">
        <FormField
          control={form.control}
          name="username"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Username</FormLabel>
              <FormControl>
                <Input placeholder="shadcn" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <Button type="submit">Submit</Button>
      </form>
    </Form>
  );
}
```

### Dialog Pattern

```typescript
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";

export function DialogExample() {
  return (
    <Dialog>
      <DialogTrigger asChild>
        <Button variant="outline">Open Dialog</Button>
      </DialogTrigger>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Are you sure?</DialogTitle>
          <DialogDescription>This action cannot be undone.</DialogDescription>
        </DialogHeader>
        <div className="flex justify-end gap-4">
          <Button variant="outline">Cancel</Button>
          <Button>Confirm</Button>
        </div>
      </DialogContent>
    </Dialog>
  );
}
```

### Card Pattern

```typescript
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
  CardFooter,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";

export function CardExample() {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Card Title</CardTitle>
        <CardDescription>Card description goes here</CardDescription>
      </CardHeader>
      <CardContent>
        <p>Card content</p>
      </CardContent>
      <CardFooter>
        <Button>Action</Button>
      </CardFooter>
    </Card>
  );
}
```

## Chartreuse Green Theme

Your project uses chartreuse green (#7fff00) as the primary accent color:

- Primary color: `#7fff00` / `hsl(84, 100%, 50%)`
- Use in: buttons, accents, highlights, active states
- CSS variable: `var(--chartreuse)` or `text-chartreuse`, `bg-chartreuse`
- Ensure sufficient contrast with dark backgrounds

## Key Reminders

1. **Always use shadcn/ui components** - Don't create custom buttons, inputs, etc. when shadcn/ui provides them
2. **Use the cn() utility** - For all className compositions
3. **Follow the type system** - Use proper TypeScript interfaces
4. **Server Components first** - Only use 'use client' when necessary
5. **Validate with Zod** - All forms and server actions
6. **Accessibility matters** - Include proper ARIA labels and semantic HTML
7. **Performance matters** - Optimize images, lazy load, minimize client JS
8. **Never create files** - Unless explicitly instructed
9. **Maintain consistency** - Follow existing patterns in the codebase
10. **Chartreuse everywhere** - Use #7fff00 for primary accent color

## Reference Links

- [shadcn/ui Documentation](https://ui.shadcn.com)
- [Next.js Documentation](https://nextjs.org/docs)
- [Tailwind CSS](https://tailwindcss.com/docs)
- [Radix UI](https://www.radix-ui.com)
- [React Hook Form](https://react-hook-form.com)
- [Zod](https://zod.dev)
